#include "Memory.h"
#include "FileIO.h"
#include "Handoff.h"
#include "Graphics.h"
#include "Utils.h"
#include <Uefi.h>
#include <Library/UefiLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Protocol/DevicePathToText.h>

#include "Autogenerated-KernelFileName.h"
#define BOOTLOADER_VERSION 1

struct KernelHandoff gKernelHandoff;

EFI_STATUS EFIAPI UefiEntry(
    IN EFI_HANDLE imgHandle,
    IN EFI_SYSTEM_TABLE* sysTable)
{
    UINTN memMapKey;
    EFI_STATUS status;

    gImageHandle = imgHandle;
    gST = sysTable;
    gBS = gST->BootServices;
    gST->ConOut->ClearScreen(gST->ConOut);

    Print(L"OS Loader version: %d \n", BOOTLOADER_VERSION);

    status = GetGopInfo(&gKernelHandoff);
    if (EFI_ERROR(status)) {
        PRINT_ERROR_CODE(L"GetGraphicsInfo", status);
        goto cleanup;
    }
    Print(L"[+] Retrieved graphics information \n");

    status = LoadFileIntoRam(&gKernelHandoff, KERNEL_FILE_NAME);
    if (EFI_ERROR(status)) {
        PRINT_ERROR_CODE(L"LoadFileIntoRam", status);
        goto cleanup;
    }
    Print(L"[+] %s loaded into ram at address: 0x%p \n",
        KERNEL_FILE_NAME,
        gKernelHandoff.kernelBaseAddress);

    // Print(L"[+] Dumping contents of gKernelHandoff \n");
    // char* base = (char*)gKernelHandoff.kernelBaseAddress;
    // for (int i = 0; i < gKernelHandoff.kernelSize; i++) {
    //     Print(L"0x%x ", base[i]);
    // }
    // Print(L"\n");

    gKernelHandoff.configurationTable = sysTable->ConfigurationTable;
    gKernelHandoff.numTableEntries= sysTable->NumberOfTableEntries;

    Print(L"kernelBaseAddress: 0x%x\n", gKernelHandoff.kernelBaseAddress);
    Print(L"kernelSize: 0x%x\n", gKernelHandoff.kernelSize);
    Print(L"memMapBaseAddress: 0x%x\n", gKernelHandoff.memMapBaseAddress);
    Print(L"memMapSize: 0x%x\n", gKernelHandoff.memMapSize);
    Print(L"configurationTable: 0x%x\n", gKernelHandoff.configurationTable);
    Print(L"numTableEntries: 0x%x\n", gKernelHandoff.numTableEntries);
    Print(L"frameBufferBaseAddr: 0x%x\n", gKernelHandoff.frameBufferBaseAddr);
    Print(L"frameBufferSize: 0x%x\n", gKernelHandoff.frameBufferSize);

    status = GetMemoryMap(&gKernelHandoff, &memMapKey);
    if (EFI_ERROR(status)) {
        PRINT_ERROR_CODE(L"GetMemoryMap", status);
        goto cleanup;
    }

    status = gBS->ExitBootServices(imgHandle, memMapKey);
    if (EFI_ERROR(status)) {
        PRINT_ERROR_CODE(L"ExitBootServices", status);
        goto cleanup;
    }

    // until kernel is bootable and stable, do not use this function.
    StartKernel(&gKernelHandoff);

cleanup:
    Print(L"[!] Failed to boot a kernel, returning to UEFI Boot Manager... \n");
    sysTable->BootServices->Stall(1000000 * 999);
    return EFI_SUCCESS;
}